///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Console language standard library:
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Order of Execution:
//              "data/stdlib.cfg"       @
//              "data/font.cfg"
//              "data/keymap.cfg"
//              "data/stdedit.cfg"      @
//              "data/sounds.cfg"
//              "data/menus.cfg"        **
//              "data/heightmap.cfg"
//              "data/blendbrush.cfg"
//              "data/game_fps.cfg"     **
//              "servers.cfg"
//      IF NOT  "config.cfg"            ###
//                  "data/defaults.cfg"
//      WRITE       "restore.cfg"
//              "autoexec.cfg"          ###
//      DO      "playsong"
//              "auth.cfg"              ### Put sensitive stuff in here, rather than "autoexec.cfg".
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
nodebug [defvar SHOW_TODO 0 0 1]; TODO = [if $SHOW_TODO [echo (concatword "^f" $arg1 "^tTODO: " $arg2)] ]
//NO_CFG 1


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  KEY BINDS:

//  Binds a key so that it will toggle a variable:
//      Example: bindvar 9 thirdperson
bindvar = [
    if (>= $numargs 3) [
        bind $arg1 [if (@arg3) [togglevar @@arg2]]
    ][
        bind $arg1 [togglevar @arg2]
    ]
]
bindvarquiet = [
    bind $arg1 [set @arg2 (= $@arg2 0)]
]

//  Same as above, but only binds for edit mode:
editbindvar = [
    if (>= $numargs 3) [
        editbind $arg1 [if (@arg3) [togglevar @@arg2]]
    ][
        editbind $arg1 [togglevar @arg2]
    ]
]
editbindvarquiet = [
    editbind $arg1 [set @arg2 (= $@arg2 0)]
]

//  Binds a key so that it will set a modifier while held down:
bindmod = [
    bind $arg1 [set @arg2 1; onrelease [set @@arg2 0]]
]

//  Same as above, but only binds for edit mode:
editbindmod = [
    editbind $arg1 [set @arg2 1; onrelease [set @@arg2 0]]
]


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  COLOR:
//#############################################################################################################################################
//colorvectoivec = [
//    // ARGS  1: [LIST] |  vec3[ FLT FLT FLT ] | R,G,B = 0.0 to 1.0
//    // RETURNS: [LIST] | ivec3[ INT INT INT ] | R,G,B = 0 to 1,000,000
//    if (&& [= $numargs 1] [= (listlen $arg1) 3]) [
//        local Red = (*f (at $arg1 0) 1000000)
//        local Grn = (*f (at $arg1 1) 1000000)
//        local Blu = (*f (at $arg1 2) 1000000)
//        result (concat $Red $Grn $Blu)
//    ][
//        result [-1 -1 -1]
//    ]
//]
//colorivectovec = [
//    // ARGS  1: [LIST] | ivec3[ INT INT INT ] | R,G,B = 0 to 1,000,000
//    // RETURNS: [LIST] |  vec3[ FLT FLT FLT ] | R,G,B = 0.0 to 1.0
//    if (&& [= $numargs 1] [= (listlen $arg1) 3]) [
//        local Red = (*f (at $arg1 0) 0.000001)
//        local Grn = (*f (at $arg1 1) 0.000001)
//        local Blu = (*f (at $arg1 2) 0.000001)
//        result (concat $Red $Grn $Blu)
//    ][
//        result [-1 -1 -1]
//    ]
//]
//
//#############################################################################################################################################
colorvectoint = [
    // ARGS  1: [LIST] | vec3[ FLT FLT FLT ] | R,G,B = 0.0 to 1.0
    // RETURNS: INT    | 0xRrGgBb
    if (&& [= $numargs 1] [= (listlen $arg1) 3]) [
        local Red = (<< (+ 0 (round (*f (at $arg1 0) 255))) 16)
        local Grn = (<< (+ 0 (round (*f (at $arg1 1) 255)))  8)
        local Blu =     (+ 0 (round (*f (at $arg1 2) 255)))
        result (+ $Red (+ $Grn $Blu))
    ][
        result -1
    ]
]

//#############################################################################################################################################
colorhsvtorgb = [
    // ARGS  1: [LIST] | vec3[ FLT FLT FLT ] | H     = 0.0 to 3.6
    //                                           S,V = 0.0 to 1.0
    // RETURNS: [LIST] | vec3[ FLT FLT FLT ] | R,G,B = 0.0 to 1.0
    if (&& [= $numargs 1] [= (listlen $arg1) 3]) [
        Hue; Hue = (at $arg1 0)
        Sat; Sat = (at $arg1 1)
        Vib; Vib = (at $arg1 2)

        c = (*f $Vib $Sat)

        x = (*f $Hue 1.66666666666666666667)
        x = (modf $x 2.0)
        x = (-f $x 1.0)
        x = (absf $x)
        x = (-f 1.0 $x)
        x = (*f $c $x)

        m = (-f $Vib $c)

        cond [&& (>=f $Hue 0.0) (<f  $Hue 0.6)] [Red =  $c; Grn =  $x; Blu = 0.0
        ]    [&& (>=f $Hue 0.6) (<f  $Hue 1.2)] [Red =  $x; Grn =  $c; Blu = 0.0
        ]    [&& (>=f $Hue 1.2) (<f  $Hue 1.8)] [Red = 0.0; Grn =  $c; Blu =  $x
        ]    [&& (>=f $Hue 1.8) (<f  $Hue 2.4)] [Red = 0.0; Grn =  $x; Blu =  $c
        ]    [&& (>=f $Hue 2.4) (<f  $Hue 3.0)] [Red =  $x; Grn = 0.0; Blu =  $c
        ]    [&& (>=f $Hue 3.0) (<=f $Hue 3.6)] [Red =  $c; Grn = 0.0; Blu =  $x
        ]

        Red = (+f $Red $m)
        Grn = (+f $Grn $m)
        Blu = (+f $Blu $m)

        // edithud_debugthis "Hue Sat Vib Min Max Dlt Red Grn Blu"
        result (concat $Red $Grn $Blu)
    ][
        result [-1 -1 -1]
    ]
]
colorrgbtohsv = [
    // ARGS  1: [LIST] | vec3[ FLT FLT FLT ] | R,G,B = 0.0 to 1.0
    // RETURNS: [LIST] | vec3[ FLT FLT FLT ] | H     = 0.0 to 3.6
    //                                           S,V = 0.0 to 1.0
    if (&& [= $numargs 1] [= (listlen $arg1) 3]) [
        Red = (at $arg1 0)
        Grn = (at $arg1 1)
        Blu = (at $arg1 2)

        Min = (minf $Red (minf $Grn $Blu))
        Max = (maxf $Red (maxf $Grn $Blu))
        Dlt = (-f $Max $Min)

        Vib = $Max

        if (&& (>f $Dlt 0.0) (>f $Max 0.0)) [
            Sat = (divf $Dlt $Max)

            cond [=f $Red $Max] [Hue =         (divf (-f $Grn $Blu) $Dlt)
            ]    [=f $Grn $Max] [Hue = (+f 2.0 (divf (-f $Blu $Red) $Dlt) )
            ]    [      1     ] [Hue = (+f 4.0 (divf (-f $Red $Grn) $Dlt) )]
            if (<f $Hue 0.0) [ Hue = (+f $Hue 6.0) ] // Wrap.
          //Hue = (divf $Hue  6.0) // 0.0 to   1.0
            Hue = (*f   $Hue  0.6) // 0.0 to   3.6
          //Hue = (*f   $Hue 60.0) // 0.0 to 360.0
        ][
            Sat = 0.0
            Hue = 0.0
        ]
        // edithud_debugthis "Red Grn Blu Min Max Dlt Hue Sat Vib"
        result (concat $Hue $Sat $Vib)
    ][
        result [-1 -1 -1]
    ]
]


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LISTS:

listswap = [
    // ARGS  1: [LIST]
    //       2: INDEX  | Indexes are ZeroInclusive.
    //       3: INDEX  |
    // RETURNS: [LIST]
    ListLen = (listlen $arg1)
    if     (|| (< $arg2 0) (>= $arg2 $ListLen)) [error "^f3ERROR -- listswap: IndexA is out of range."; result $arg1][
        if (|| (< $arg3 0) (>= $arg3 $ListLen)) [error "^f3ERROR -- listswap: IndexB is out of range."; result $arg1][
            Result = $arg1
            HoldMe = (escape (at $Result $arg2))
            Result = (listsplice $Result (escape (at $Result $arg3)) $arg2 1)
            Result = (listsplice $Result             $HoldMe         $arg3 1)
            result $Result
        ]
    ]
]

listshuffle = [
    // ARGS  1: [LIST]
    // RETURNS: [LIST] | Shuffled.
    if (&& [= $numargs 1] [> (listlen $arg1) 1]) [
        Result = $arg1
        ListLen = (listlen $Result)
        loop i (- $ListLen 1) [ // -1, no need to swap last index with itself.
            // Swap current item with any item AFTER it, including itself:
            Result = (listswap $Result $i (rnd $ListLen $i))
        ]
        result $Result
    ][
        result 0
    ]
]


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  MISCELLANEOUS:

_FOV_GetHorzFromVert = [result (*f 2.0 (atan (*f (tan (divf $arg1 2.0)) (divf $scr_w $scr_h)) ))]
_FOV_GetVertFromHorz = [result (*f 2.0 (atan (*f (tan (divf $fov  2.0)) (divf $scr_h $scr_w)) ))]
fovh = [
    if (> $numargs 0) [fov $arg1]
    echo "^f~fov vertical   =" (_FOV_GetVertFromHorz)
    echo "^f~fov horizontal =" $fov
]
fovv = [
    if (> $numargs 0) [fov (round (_FOV_GetHorzFromVert $arg1))]
    echo "^f~fov vertical   =" (_FOV_GetVertFromHorz)
    echo "^f~fov horizontal =" $fov
]


+fround = [round (+f $arg1 $arg2) (absf $arg2)]


ingame   = [if (isconnected)     [result 1] [result 0]] //  For clarity/readability.
ingamemp = [if (isconnected 0 0) [result 1] [result 0]]


loadsky = [ // Legacy-ish Alias.
    skybox $arg1
    if (> $numargs 1) [ spinsky $arg2 ] [ if (!=f $spinsky 0.0) [spinsky 0.0] ]
]


//  Creates a macro whose body is a format string.
//      Example: macro greet [ say Hi, %1! ]
macro = [
    $arg1 = (concat [format [@@arg2]] (loopconcat i $numargs [concatword " $arg" (+ $i 1)]))
]


mapmsg = [ maptitle $arg1 ] // Legacy Alias.


//  Edit the contents of an alias/command/var via the console:
//      Mostly useful for Lists.
modify = [
    if (getalias $arg1)[
        if (> (listlen $$arg1) 1) [
            saycommand (concatword "/" $arg1 " = " (escape $$arg1))
        ][
            saycommand (concatword "/" $arg1 " = " $$arg1)
        ]

    ][
        if (> (listlen $$arg1) 1) [
            saycommand (concatword "/" $arg1 " " (escape $$arg1))
        ][
            saycommand (concatword "/" $arg1 " " $$arg1)
        ]
    ]
]


quine = [ echo (format "quine = [%1]" $quine) ]


reloadmap    = [map $mapname]
reloadmapcfg = [exec $mapcfgname]


soundbufferlengthtomillis = [
    if $stereo [
        result (divf (divf $soundbufferlen 2) $soundfreq)
    ][
        result (divf       $soundbufferlen    $soundfreq)
    ]
]


togglevar = [
    set $arg1 (= $$arg1 0)
    if (= $$arg1 0) [echo $arg1 "OFF"] [echo $arg1 "ON"]
]
togglevarquiet = [set $arg1 (= $$arg1 0)]

